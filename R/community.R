color_vector <- c( "#d1ea2c", "#fd5306", "#68b033", "#8601b0", "#fe2712", "#a7184d", "#3c02a6",  "#fd9a01", "#0392ce")

#' Community Detection for Transition Networks
#'
#' This function detects communities within the transition networks (represented
#' by the `tna` object).
#' It uses various algorithms to find communities in the graph representation of
#' transitions and returns a list of communities for each cluster or a specified cluster.
#'
#' @param x A `tna` object that contains transition matrices.
#' @param cluster An optional argument specifying which cluster to analyze.
#' If `NULL`, the function will analyze all clusters in `x`.
#' @param Gamma A numeric parameter that affects the behavior of certain algorithms
#' like the Spin Glass method. Defaults to `1`.
#' @details
#' If multiple transition matrices exist, the function iterates over each cluster
#' in the `tna` object to find communities using different algorithms.
#' The function uses the `igraph` package to convert the transition matrices into
#' graphs and then applies community detection algorithms (e.g., Walktrap, Fast
#' Greedy, Label Propagation, Infomap, Edge Betweenness, Leading Eigenvector,
#' and Spin Glass).
#'
#' @return A list where each element represents the result of community detection
#' for a specific cluster. Each cluster's result is returned by the internal
#' `find_communities` function, which provides community counts and assignments
#' across different algorithms.
#' @family patterns
#' @author
#' Mohammed Saqr (\email{mohammed.saqr@uef.fi})
#' @examples
#' \dontrun{
#' # Detect communities for all clusters
#' communities <- community_detection(tna_model)
#'
#' # Detect communities for a specific cluster
#' communities <- community_detection(tna_model, cluster = 1)
#' }
#' @export
community_detection <- function(x, cluster = NULL, Gamma = 1) {
  stopifnot_(
    is_tna(x),
    "Argument {.arg x} must be a {.cls tna} object."
  )

  result_list = list()

  if (length(x$transits) > 1L & is.null(cluster)) {
    for(clus in names(x$transits)) {
        info_(paste0("Finding communities for ", clus))
        g <- igraph::graph_from_adjacency_matrix(x$transits[[clus]], mode = "directed", weighted = TRUE)
        result_list[[clus]] <- find_communities(g, Gamma = Gamma)
    }
  } else {
    clus <- ifelse(is.null(cluster), 1, cluster)
    info_(paste0("Finding communities for: ", clus))
    g <- igraph::graph_from_adjacency_matrix(x$transits[[clus]], mode = "directed", weighted = TRUE)

    result_list[[clus]] <- find_communities(g, Gamma = Gamma)
  }
  result_list
}


#' Plot Communities
#'
#' This function visualizes the communities detected within a `tna` object based
#' on different community detection algorithms and their corresponding color mappings.
#'
#' @param x A `tna` object, which represents a temporal network analysis object
#' containing data to be plotted. The object should include a component `transits`
#' that can be iterated over to plot individual communities.
#' @param community_assignment A list containing the community assignments
#' generated by the `find_communities` function. Each community detection method
#' maps nodes or points in the `tna` object to specific communities.
#' @param community A named community detection method to use for coloring the
#' plot. This can be one of the following:
#' - `walktrap`: A community detection method using short random walks.
#' - `fast_greedy`: A method based on modularity optimization.
#' - `label_prop`: A method that uses label propagation.
#' - `infomap`: A method that uses information flow to detect communities.
#' - `edge_betweenness`: A method that uses edge betweenness to find communities.
#' - `leading_eigen`: A method using the leading eigenvector of the modularity matrix.
#' - `spinglass`: A method based on the spinglass model.
#' @param color_palette A vector of colors used for visualizing community assignments.
#'
#' @details
#' The function iterates over the `transits` element of the `tna` object and
#' generates plots for each using the specified community detection method. The
#' `community_assignment` provides the mapping of nodes to communities, and
#' colors are assigned based on the `community` parameter's chosen algorithm.
#' @author
#' Sonsoles LÃ³pez-Pernas (\email{sonsoles.lopez@uef.fi})
#' @family patterns
#' @examples
#' \dontrun{
#' # Assuming 'tna_model' is a tna object and 'community_assignment'
#' holds the respective community labels
#' plot_communities(tna_model, community_assignment, "walktrap")
#' }
#' @export
plot_communities <- function(x, community_assignment, community, color_palette = color_vector) {
  for(i in 1:length(x$transits)) {
    print((community_assignment[i][[1]]$community_assignments[,community]))
    print(map_to_color(community_assignment[i][[1]]$community_assignments[,community], color_palette))
    plot(x, cluster = i,
         color = map_to_color(community_assignment[i][[1]]$community_assignments[,community], color_palette))
  }
}

#' Internal Community Detection Function
#'
#' This function detects communities in a given graph using various algorithms
#' provided by the `igraph` package.
#'
#' @param g An `igraph` object representing the transition network.
#' @param Gamma A numeric parameter that influences the Spin Glass algorithm. Defaults to `1`.
#' @author
#' Mohammed Saqr (\email{mohammed.saqr@uef.fi})
#' @details
#' This function applies multiple community detection algorithms (e.g., Walktrap,
#' Fast Greedy, Label Propagation, Infomap, Edge Betweenness, Leading Eigenvector,
#' and Spin Glass) to the input graph `g`. It then constructs a dataframe of
#' community assignments and a list of the number of communities detected by each algorithm.
#'
#' @return A list containing:
#' \itemize{
#'   \item `community_counts`: A list with the number of communities found by each algorithm.
#'   \item `community_assignments`: A dataframe where each row corresponds to a
#'   node and each column to a community detection algorithm, with color-coded
#'   community assignments.
#' }
#'
find_communities <- function(g, Gamma = 1) {
  # Find communities using different algorithms and assign to named objects

  # Walktrap algorithm
  communities_walktrap <- igraph::cluster_walktrap(g, weights = igraph::E(g)$weight)
  walktrap_mapping <- igraph::membership(communities_walktrap) |> as.numeric()

  # Fast greedy algorithm (requires undirected graph)
  g_undirected <- igraph::as.undirected(g, mode = "collapse",
                                        edge.attr.comb = list(weight = "sum"))
  communities_fast_greedy <- igraph::cluster_fast_greedy(g_undirected,
                                                         weights = igraph::E(g_undirected)$weight)
  fast_greedy_mapping <- igraph::membership(communities_fast_greedy) |> as.numeric()

  # Label propagation algorithm
  communities_label_prop <- igraph::cluster_label_prop(g,
                                                       weights = igraph::E(g)$weight)
  label_prop_mapping <- igraph::membership(communities_label_prop) |> as.numeric()

  # Infomap algorithm
  communities_infomap <- igraph::cluster_infomap(g,
                                                 e.weights = igraph::E(g)$weight)
  infomap_mapping <- igraph::membership(communities_infomap) |> as.numeric()

  # Edge betweenness algorithm
  communities_edge_betweenness <- igraph::cluster_edge_betweenness(g,
                                                                   weights = igraph::E(g)$weight)
  edge_betweenness_mapping <- igraph::membership(communities_edge_betweenness) |> as.numeric()

  # Leading eigenvector algorithm
  communities_leading_eigen <- igraph::cluster_leading_eigen(g,
                                                             weights = igraph::E(g)$weight)
  leading_eigen_mapping <- igraph::membership(communities_leading_eigen) |> as.numeric()

  # Spin glass algorithm (requires undirected graph)
  communities_spinglass <- igraph::cluster_spinglass(g_undirected,
                                                     weights = igraph::E(g_undirected)$weight,
                                                     gamma = Gamma)
  spinglass_mapping <- igraph::membership(communities_spinglass) |> as.numeric()

  # Create a dataframe with all community assignments
  community_assignments <- data.frame(
    node = igraph::V(g)$name,
    walktrap = (walktrap_mapping),
    fast_greedy = (fast_greedy_mapping),
    label_prop = (label_prop_mapping),
    infomap = (infomap_mapping),
    edge_betweenness = (edge_betweenness_mapping),
    leading_eigen = (leading_eigen_mapping),
    spinglass = (spinglass_mapping)
  )
  print(label_prop_mapping)
  # Create a list with the number of communities found by each algorithm
  community_counts <- list(
    walktrap = length(communities_walktrap),
    fast_greedy = length(communities_fast_greedy),
    label_prop = length(communities_label_prop),
    infomap = length(communities_infomap),
    edge_betweenness = length(communities_edge_betweenness),
    leading_eigen = length(communities_leading_eigen),
    spinglass = length(communities_spinglass)
  )

  # Create the result object
  result <- list(
    community_counts = community_counts,
    community_assignments = community_assignments
  )

  # Print the number of communities found by each algorithm
  info_("Number of communities found by each algorithm:\n")
  info_(paste(result$community_counts, collapse = ", "))

  # Display the community assignments dataframe
  info_("\nCommunity assignments:\n")
  print_(result$community_assignments)

  # Return the result object
  return(result)
}
