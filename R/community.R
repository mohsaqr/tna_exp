color_vector <- c( "#d1ea2c", "#fd5306", "#68b033", "#8601b0", "#fe2712", "#a7184d", "#3c02a6",  "#fd9a01", "#0392ce")

#' @export
community_detection <- function(x, cluster = NULL, Gamma = 1, color_palette = color_vector) {
  stopifnot_(
    is_tna(x),
    "Argument {.arg x} must be a {.cls tna} object."
  )

  result_list = list()

  if (length(x$transits) > 1L & is.null(cluster)) {
    for(clus in names(x$transits)) {
        print(paste0("Finding communities for ", clus))
        g <- igraph::graph_from_adjacency_matrix(x$transits[[clus]], mode = "directed", weighted = TRUE)
        result_list[[clus]] <- find_communities(g, Gamma = Gamma, color_palette = color_palette)
    }
  } else {
    clus <- ifelse(is.null(cluster), 1, cluster)
    print(paste0("Finding communities for: ", clus))
    g <- igraph::graph_from_adjacency_matrix(x$transits[[clus]], mode = "directed", weighted = TRUE)

    result_list[[clus]] <- find_communities(g, Gamma = Gamma, color_palette = color_palette)
  }
  result_list
}


#' Plot Communities
#'
#' This function visualizes the communities detected within a `tna` object based on different community detection algorithms and their corresponding color mappings.
#'
#' @param x A `tna` object, which represents a temporal network analysis object containing data to be plotted. The object should include a component `transits` that can be iterated over to plot individual communities.
#' @param community_assignment A list containing the community assignments generated by the `find_communities` function. Each community detection method maps nodes or points in the `tna` object to specific communities.
#' @param community A named community detection method to use for coloring the plot. This can be one of the following:
#' - `walktrap`: A community detection method using short random walks.
#' - `fast_greedy`: A method based on modularity optimization.
#' - `label_prop`: A method that uses label propagation.
#' - `infomap`: A method that uses information flow to detect communities.
#' - `edge_betweenness`: A method that uses edge betweenness to find communities.
#' - `leading_eigen`: A method using the leading eigenvector of the modularity matrix.
#' - `spinglass`: A method based on the spinglass model.
#'
#' @details
#' The function iterates over the `transits` element of the `tna` object and generates plots for each using the specified community detection method. The `community_assignment` provides the mapping of nodes to communities, and colors are assigned based on the `community` parameter's chosen algorithm.
#'
#' @examples
#' # Example usage:
#' # Assuming 'x' is a tna object and 'community_assignment' holds the respective community labels
#' plot_communities(x, community_assignment, "walktrap")
#'
#' @export
plot_communities <- function(x, community_assignment, community) {
  for(i in 1:length(x$transits)) {
    plot(x, cluster = i, color = community_assignment[i][[1]]$community_assignments[,community])
  }
}


find_communities <- function(g, Gamma = 1, color_palette = color_vector) {
  # Find communities using different algorithms and assign to named objects

  # Walktrap algorithm
  communities_walktrap <- igraph::cluster_walktrap(g, weights = igraph::E(g)$weight)
  walktrap_mapping <- igraph::membership(communities_walktrap) |> as.numeric()

  # Fast greedy algorithm (requires undirected graph)
  g_undirected <- igraph::as.undirected(g, mode = "collapse",
                                        edge.attr.comb = list(weight = "sum"))
  communities_fast_greedy <- igraph::cluster_fast_greedy(g_undirected,
                                                         weights = igraph::E(g_undirected)$weight)
  fast_greedy_mapping <- igraph::membership(communities_fast_greedy) |> as.numeric()

  # Label propagation algorithm
  communities_label_prop <- igraph::cluster_label_prop(g,
                                                       weights = igraph::E(g)$weight)
  label_prop_mapping <- igraph::membership(communities_label_prop) |> as.numeric()

  # Infomap algorithm
  communities_infomap <- igraph::cluster_infomap(g,
                                                 e.weights = igraph::E(g)$weight)
  infomap_mapping <- igraph::membership(communities_infomap) |> as.numeric()

  # Edge betweenness algorithm
  communities_edge_betweenness <- igraph::cluster_edge_betweenness(g,
                                                                   weights = igraph::E(g)$weight)
  edge_betweenness_mapping <- igraph::membership(communities_edge_betweenness) |> as.numeric()

  # Leading eigenvector algorithm
  communities_leading_eigen <- igraph::cluster_leading_eigen(g,
                                                             weights = igraph::E(g)$weight)
  leading_eigen_mapping <- igraph::membership(communities_leading_eigen) |> as.numeric()

  # Spin glass algorithm (requires undirected graph)
  communities_spinglass <- igraph::cluster_spinglass(g_undirected,
                                                     weights = igraph::E(g_undirected)$weight,
                                                     gamma = Gamma)
  spinglass_mapping <- igraph::membership(communities_spinglass) |> as.numeric()

  # Create a dataframe with all community assignments
  community_assignments <- data.frame(
    node = igraph::V(g)$name,
    walktrap = map_to_color(walktrap_mapping, color_palette),
    fast_greedy = map_to_color(fast_greedy_mapping, color_palette),
    label_prop = map_to_color(label_prop_mapping, color_palette),
    infomap = map_to_color(infomap_mapping, color_palette),
    edge_betweenness = map_to_color(edge_betweenness_mapping, color_palette),
    leading_eigen = map_to_color(leading_eigen_mapping, color_palette),
    spinglass = map_to_color(spinglass_mapping, color_palette)
  )

  # Create a list with the number of communities found by each algorithm
  community_counts <- list(
    walktrap = length(communities_walktrap),
    fast_greedy = length(communities_fast_greedy),
    label_prop = length(communities_label_prop),
    infomap = length(communities_infomap),
    edge_betweenness = length(communities_edge_betweenness),
    leading_eigen = length(communities_leading_eigen),
    spinglass = length(communities_spinglass)
  )

  # Create the result object
  result <- list(
    community_counts = community_counts,
    community_assignments = community_assignments
  )

  # Print the number of communities found by each algorithm
  cat("Number of communities found by each algorithm:\n")
  print(result$community_counts)

  # Display the community assignments dataframe
  cat("\nCommunity assignments:\n")
  print(result$community_assignments)

  # Return the result object
  return(result)
}
