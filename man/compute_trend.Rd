% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ts.R
\name{compute_trend}
\alias{compute_trend}
\title{Compute trend classification based on various metrics}
\usage{
compute_trend(
  data,
  window,
  method = "slope",
  slope = "robust",
  epsilon = 0.05,
  turbulence_threshold = 5,
  flat_to_turbulent_factor = 1.5,
  align = "center"
)
}
\arguments{
\item{data}{A \code{ts} object or a \code{numeric} vector
representing the time series.}

\item{method}{A \code{character} string, method for trend calculation. Options:
\code{"slope"} (default), \code{"ar1"}, \code{"growth_factor"}.}

\item{slope}{A \code{character} string, method for slope calculation if
\code{method = "slope"}. Options: \code{"ols"} (ordinary least squares),
\code{"robust"} (Theil-Sen estimator), \code{"spearman"}
(Spearman rank correlation based), \code{"kendall"} (Kendall's tau based).
Default: \code{"robust"}.}

\item{epsilon}{A \code{numeric} value, threshold for defining flat trends based
on the metric value. For \code{method = "slope"}, values between
\verb{(-epsilon, +epsilon)} are considered flat.
For \code{"ar1"} or \code{"growth_factor"}, values between
(1-epsilon) and (1+epsilon) are considered flat. Default: 0.05.}

\item{turbulence_threshold}{A \code{numeric} value, baseline threshold for
classifying a segment as "turbulent". Based on a custom combined volatility
metric (CV + 0.5 * range factor of rolling metric values).
Default: 5.}

\item{flat_to_turbulent_factor}{A \code{numeric} value, a multiplier for
\code{turbulence_threshold} when assessing if an already "flat" segment should
be reclassified as "turbulent". A value > 1 makes "flat" trends more
resistant to becoming "turbulent". Default: 1.5.}

\item{align}{A \code{character} string, alignment of the window. Options:
"center" (default), "right", "left". The calculated metric is assigned to
the center, rightmost, or leftmost point of the window respectively.}

\item{window_size}{An \code{integer}, window size for metric calculation.
If missing, uses adaptive sizing:
\code{max(3, min(length(data), round(length(data)/10)))}.}
}
\value{
A data.frame containing:
\itemize{
\item \code{data}: The original time series data (as \code{numeric}).
\item \code{time_index}: The time index for the data.
\item \code{metric_values}: Calculated metric values for each point where calculable.
\item \code{trend_codes}: Character vector of trend classifications: "ascending",
"descending", "flat", "turbulent", "Missing_Data", or "Initial".
}
}
\description{
Calculates rolling metrics for a time series and classifies trends
as ascending, descending, flat, or turbulent.
}
\details{
Computes rolling metrics. Trend classifications
("ascending", "descending", "flat") are first determined using \code{epsilon}.
Then, a "turbulent" classification can override these if the rolling
volatility of the metric exceeds a dynamically adjusted turbulence threshold.
For segments initially classified as "flat", this threshold is
\code{turbulence_threshold * flat_to_turbulent_factor},
making them more stable against reclassification as "turbulent" due to minor
noise.
}
\examples{
set.seed(123)
x <- cumsum(rnorm(200)) # Longer series to see more varied trends
# Using a slightly larger epsilon to catch more "flat" regions
trend <- compute_trend(
  x, window = 15, method = "slope",
  slope = "ols", epsilon = 0.1,
  turbulence_threshold = 5, flat_to_turbulent_factor = 2
)

}
