% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ts.R
\name{prepare_ts}
\alias{prepare_ts}
\alias{prepare_ts.ts}
\alias{prepare_ts.default}
\title{Import and Convert Time-Series Data into Wide Format Sequence Data}
\usage{
prepare_ts(
  data,
  n_states,
  labels = 1:n_states,
  method = "kmeans",
  unused_fn = dplyr::first,
  ...
)

\method{prepare_ts}{ts}(
  data,
  n_states,
  labels = 1:n_states,
  method = "kmeans",
  unused_fn = dplyr::first,
  ...
)

\method{prepare_ts}{default}(
  data,
  id_col,
  value_col,
  order_col,
  n_states,
  labels = 1:n_states,
  method = "kmeans",
  unused_fn = dplyr::first,
  ...
)
}
\arguments{
\item{data}{A \code{data.frame} containing time-series data in long format, or
a \code{ts} object.}

\item{n_states}{An \code{integer} specifying the number of states.}

\item{labels}{An \code{character} vector specifying the names of the states. The
length must be \code{n_states} The defaults is consecutive numbering,
i.e. \code{1:n_states}.}

\item{method}{A \code{character} string defining the discretization method to use.
The available options are:
\itemize{
\item \code{kmeans}: for K-means clustering (the default).
\item \code{width}: for equal width binning.
\item \code{quantile}: for quantile-based binning.
\item \code{kde}: for binning based on kernel density estimation.
\item \code{gaussian}: for a Gaussian mixture model.
}}

\item{unused_fn}{How to handle extra columns when pivoting to wide format.
See \code{\link[tidyr:pivot_wider]{tidyr::pivot_wider()}}. The default is to keep all columns and to
use the first value.}

\item{...}{Additional arguments passed to the discretization method
(\code{\link[stats:kmeans]{stats::kmeans()}} for \code{kmeans}, \code{\link[stats:density]{stats::density()}} and
\code{\link[pracma:findpeaks]{pracma::findpeaks()}} for \code{kde}, and
\code{\link[mclust:Mclust]{mclust::Mclust()}} for \code{gaussian}).}

\item{id_col}{An optional \code{character} string naming the column that contains
the unique IDs.}

\item{value_col}{A \code{character} string naming the column that contains the
data values.}

\item{order_col}{A \code{character} string naming the column that contains the
time variable (not required if the data is already in order),}
}
\value{
A \code{tna_data} object, which is a \code{list} with the following elements:
\itemize{
\item \code{long_data}: The processed data in long format.
\item \code{sequence_data}: The processed data on the sequences in wide format,
with time points as different variables structured with sequences.
\item \code{meta_data}: Other variables from the original data in wide format.
\item \code{statistics}: A \code{list} of two \code{tibble}s, \code{global} and \code{local}, that contain
descriptive statistics of the \code{value_col} variable for each state, and
for each state an ID of \code{id_col}, respectively.
}
}
\description{
Imports time-series data as sequence data via discretization.
Various methods for discretization are available including gaussian mixtures,
K-means clustering and kernel density based binning.
}
\examples{
# Long format data
ts_data <- data.frame(
  id = gl(10, 100),
  series = c(
    replicate(
      10,
      stats::arima.sim(list(order = c(2, 1, 0), ar = c(0.5, 0.2)), n = 99)
    )
  )
)
data <- prepare_ts(ts_data, "id", "series", n_states = 3)

# Time-series data
data <- prepare_ts(EuStockMarkets, n_states = 3)

}
\seealso{
Other data: 
\code{\link{import_data}()},
\code{\link{prepare_data}()},
\code{\link{print.tna_data}()},
\code{\link{simulate.tna}()}
}
\concept{data}
